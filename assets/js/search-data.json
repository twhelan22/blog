{
  
    
        "post0": {
            "title": "Evaluating penalty takers using empirical Bayes estimation",
            "content": "Why do we assume every player is equally skilled from the penalty spot? . Last weekend there were two big penalty misses in the Premier league, one by Kevin De Bruyne against Liverpool and the other by Ademola Lookman against West Ham, both of which resulted in dropped points for their respective teams. It&#39;s rare to see two penalties that bad in the same weekend - in fact the last time someone completely missed the target from the spot in the Premier league also cost Manchester City three points against Liverpool! So why was Lookman even taking Fulham&#39;s penalty in the first place, and are City so bad at penalties that Ederson might actually be the best man for the job? . Trying to quantify finishing skill is not a new idea in the football analytics community, but penalties are usually an afterthought in the analysis (if they are considered at all). I&#39;ve seen plenty of posts about expected goals (I&#39;ve even written some), and the typical process of dealing with penalties is to just throw away the data and assume penalty xG = penalties taken * average conversion rate. I have been guilty of that myself, but are we really saying Gabriel Jesus (4/10 penalties scored) is just as good as Yaya Tour√© (15/15)? Is Tour√© the same as Matt Le Tissier (27/27)? There are plenty of &#39;best penalty takers of all time&#39; articles that suggest otherwise (1.16 million results on Google). We can do better. . Here are some typical reasons people give for ignoring finishing skill estimates: . On-ball data is noisy and we are missing key information about defender positions, whether the shot with the player&#39;s strong or weak foot and countless other variables. | The sample size of shots from any given location is small. | Even if we could find some signal in the noise, there probably isn&#39;t much difference between the best finisher and the worst anyway. | Whilst you might be able to get away with that line of thinking in general, it seems odd to apply that logic to penalties, since: . The most important concerns aren&#39;t a factor here; the main differences between one penalty and another are goalkeeper skill, pitch conditions, and (dare I say it!) confidence. We could make this process significantly more complicated by trying to account for those variables, but that might be overthinking things given what we&#39;re trying to accomplish. Unlike open-play shots a rocket into the top corner isn&#39;t necessarily better than a delicate chip down the middle (unless your name is Ademola Lookman!), so we can focus more on the results than the execution. If a club wanted to use this process to find their best penalty taker these variables could be controlled, for example by having a penalty shootout (pressure/competitive element) at the end of training (same goalkeeper/pitch conditions) to build up a large sample size of penalty shots for each player in the squad, so a simple model could be just as useful in practice as a more complex one. | We still won&#39;t have a huge sample size with penalties, but at least the shot location is fixed. | Intuitively we know there is at least some difference, so why don&#39;t we try to investigate further? | Empirical Bayes estimation . There are several methods we could use to create a penalty taking skill estimate, but by far the easiest is &#39;empirical Bayes estimation&#39;. . Important: This analysis is heavily inspired by David Robinson&#8217;s excellent post &#8217;Understanding empirical Bayes estimation (using baseball statistics)&#8217;. Since I prefer Python to R I&#8217;ll be replicating some of the steps he used but I won&#8217;t be going as in-depth, so I highly suggest reading through his post as well if you have time! . As you&#39;ll see in a moment we have data on penalties scored and penalties taken for different players, and we want to estimate penalty conversion rate (scored/taken). Robinson has shown that data in this form can be modelled using a beta distribution. In his words: . &quot;The beta distribution can be understood as representing a probability distribution of probabilities - that is, it represents all the possible values of a probability when we don‚Äôt know what that probability is.&quot; . In our case the probability we are looking to estimate is penalty conversion rate (or &#39;probability of a succesful penalty&#39;). Of course we could just take the actual rate, but that&#39;s not very useful in practice. Say John Smith has scored 3/3 penalties, do we really think he is incapable of missing? It would be preferable to ask &#39;what is our realistic best estimate of Smith&#39;s conversion rate given the fact that he has scored 3/3 so far?&#39; This method is known as &#39;Bayesian inference&#39;; we start with a prior estimate of conversion rate (e.g. the league average distribution) and update our estimate to reflect the new evidence we have on Smith (3/3 penalties scored). . Note: I&#8217;m not going to spend much time explaining Bayes&#8217; Theorem, so if you haven&#8217;t come across it before see here for a primer (or here for the short version). . In standard Bayesian inference we usually decide on the prior distribution ahead of time, but we can approximate this method by estimating the prior distribution from our data instead (hence &#39;empirical estimation&#39;). To obtain our prior we&#39;ll follow Robinson&#39;s method - fit a beta distribution to the data and use that as a starting point for each player or team&#39;s prediction. . Estimate a prior from the data . The main dataset we will be using is from FBRef&#39;s Big 5 European Leagues Stats page. Let&#39;s load it in now. . Note: I am ignoring goalkeeper skill for this analysis, but goalkeeper data is also available at FBRef if you want to repeat the steps to estimate penalty save percentage instead! If you aren&#8217;t familiar with Python I wrote an introductory series that you can check out here. . df = pd.read_csv(&#39;https://raw.githubusercontent.com/twhelan22/blog/master/data/big_five_penalties.csv&#39;, encoding=&#39;utf-8&#39;) df.head() . . name team league season penalties_scored penalties_taken . 0 Matt Le Tissier | Southampton | England | 1992 | 2 | 2 | . 1 Dean Saunders | Aston Villa | England | 1992 | 1 | 2 | . 2 Alan Shearer | Blackburn | England | 1992 | 3 | 3 | . 3 John Sheridan | Sheffield Weds | England | 1992 | 2 | 2 | . 4 Andy Sinton | QPR | England | 1992 | 1 | 2 | . The dataset contains penalty statistics for players in France, Germany, Italy, Spain and England&#39;s top division from the 92/93 season to November 2020. Whilst that sounds like a lot of data, most of the players have only taken a handful of penalties: . players = df.groupby(&#39;name&#39;)[[&#39;penalties_scored&#39;, &#39;penalties_taken&#39;]].sum().reset_index() def conversion_rate(df): df[&#39;conversion_rate&#39;] = df[&#39;penalties_scored&#39;] / df[&#39;penalties_taken&#39;] return conversion_rate(players) players.describe() . . penalties_scored penalties_taken conversion_rate . count 2204.00 | 2204.00 | 2204.00 | . mean 3.90 | 5.02 | 0.71 | . std 6.00 | 7.13 | 0.34 | . min 0.00 | 1.00 | 0.00 | . 25% 1.00 | 1.00 | 0.50 | . 50% 2.00 | 2.00 | 0.83 | . 75% 5.00 | 6.00 | 1.00 | . max 91.00 | 105.00 | 1.00 | . This means that over half of the players in the dataset have a conversion rate of 100% or 0%: . sns.displot(data=players, x=&#39;conversion_rate&#39;, kde=True); . . Clearly those players would add a lot of noise to our estimate, but we don&#39;t want to just throw out a big chunk of data if we can help it. To get around this problem, we can groupby &#39;team&#39; and fit a beta distribution to the resulting team-level data instead. We can then use that prior to get predictions for each player afterwards. . Note: If you have a bigger dataset you could use players to get the prior instead! . That looks much more reasonable already! Let&#39;s filter out teams with fewer than 10 attempts and see what we&#39;re left with. . This is what we&#39;d expect to see intuitively; most of the teams are close to the average, with a few teams having performed significantly better or worse than average. Let&#39;s try to fit a beta distribution to this data: . # Plot the distribution of actual conversion rate (our original data) palette = sns.color_palette() fig, ax = plt.subplots(figsize=(8,5)) ax.xaxis.set_major_formatter(matplotlib.ticker.PercentFormatter(1)) sns.kdeplot(data=teams_filt[&#39;conversion_rate&#39;]) # Fit a beta distribution to the data to get the alpha0 and beta0 parameters # Note that for this to work 0 &lt; data &lt; 1, which is OK in this case, # since a predicted conversion rate of 0% or 100% isn&#39;t realistic in practice alpha0, beta0, _, _ = ss.beta.fit(teams_filt[&#39;conversion_rate&#39;], floc=0, fscale=1) # Generate a beta distribution using alpha0 and beta0 (the prior distribution) prior_dist = ss.beta.rvs(alpha0, beta0, size=10000) # Plot the random beta distribution we just generated sns.kdeplot(data=prior_dist) # Add legend custom_lines = [Line2D([0], [0], color=palette[0], lw=2.5), Line2D([0], [0], color=palette[1], lw=2.5)] ax.legend(custom_lines, [&#39;Actual conversion rate&#39;, &#39;Random beta distribution: nalpha0={:.2f}, beta0={:.2f}&#39;.format(alpha0, beta0)]); . . That looks good enough for what we are trying to acomplish here! The beta distribution we just generated is defined as: . $X sim Beta( alpha_0, beta_0)$ . So what are $ alpha_0$ and $ beta_0$? In this case $ alpha_0$ = penalties scored and $ beta_0$ = penalties missed. With zero evidence we are going to start with the assumption that every player or team has scored $ alpha_0$ times and missed $ beta_0$ times. Our prior estimate of conversion rate is therefore: . $prior :estimate = frac{starting :goals}{starting :goals :+ :starting :misses} = frac{ alpha_0}{ alpha_0 :+ : beta_0}$ . We are essentially giving everyone a &#39;head start&#39; by assuming they have already taken some penalties and converted them at an average rate, which gets around the issue of small sample sizes. To incorporate the additional evidence we have for a particular player or team, we update their distribution as follows: . $Beta( alpha_0 :+ :goals, beta_0 :+ :misses)$ . Let&#39;s take a look at this in action to get a better understanding of the process. . Visualising the effects of empirical Bayes . # Define a function to get predicted conversion rate using alpha0 and beta0 def predicted_conversion(scored, taken, alpha=alpha0, beta=beta0): return (alpha0 + scored) / (alpha0 + beta0 + taken) prior = predicted_conversion(scored=0, taken=0) print(&#39;Start off with alpha0 = {:.2f} goals and beta0 = {:.2f} misses:&#39;.format(alpha0, beta0)) print(&#39;Prior estimate = {:.2f} / ({:.2f} + {:.2f}) = {:.2%} n&#39;.format(alpha0, alpha0, beta0, prior)) print(&#39;Then every time a penalty is taken, add the results to the starting estimate:&#39;) print(&#39;New estimate = (alpha0 + penalties_scored) / (alpha0 + beta0 + penalties_taken) n&#39;) sns.set(style=&#39;ticks&#39;) def plot_dist(scored, missed): taken = scored + missed new_estimate = predicted_conversion(scored=scored, taken=taken) # Plot the prior distribution fig, ax = plt.subplots(figsize=(9,6)) ax.set(title=&#39;After {:n} taken, {:n} scored: estimate = ({:.2f} + {:n}) / ({:.2f} + {:.2f} + {:n}) = {:.2%}&#39;.format(taken, scored, alpha0, scored, alpha0, beta0, taken, new_estimate), ylim=[0, 8], xlabel=&#39;Predicted penalty conversion rate&#39;) ax.xaxis.set_major_formatter(matplotlib.ticker.PercentFormatter(1)) sns.kdeplot(data=prior_dist, color=palette[-1], fill=True) plt.axvline(prior, 0, 0.95, color=palette[-1], linestyle=&#39;--&#39;) # Plot the new distribution new_dist = ss.beta.rvs(alpha0+scored, beta0+missed, size=10000) sns.kdeplot(data=new_dist, color=palette[3]) plt.axvline(new_estimate, 0, 0.95, color=palette[3], linestyle=&#39;--&#39;) # Add custom legend and axes custom_lines = [Line2D([0], [0], color=palette[3], lw=2.5), Line2D([0], [0], color=palette[-1], lw=2.5)] ax.legend(custom_lines, [&#39;New estimate: %s&#39; % (str(round(new_estimate*100, 2)))+&#39;%&#39;, &#39;Prior estimate: %s&#39; % (str(round(prior*100, 2)))+&#39;%&#39;], loc=&#39;upper left&#39;) sns.despine(right=True, top=True); plot_dist(1, 0) plot_dist(10, 1) . . Start off with alpha0 = 30.83 goals and beta0 = 8.82 misses: Prior estimate = 30.83 / (30.83 + 8.82) = 77.76% Then every time a penalty is taken, add the results to the starting estimate: New estimate = (alpha0 + penalties_scored) / (alpha0 + beta0 + penalties_taken) . After 1 taken, 1 scored our new estimate is very similar to the prior distribution - we don&#39;t want to make drastic changes after just one penalty! After 11 taken, 10 scored the new distribution is taller and narrower, since we are starting to get more confident in our estimate now we have more information. The new distribution has also shifted to the right, since we think it&#39;s more likely this player is above average. However, even with more evidence this player&#39;s predicted conversion rate of 80.61% is still closer to the average rate than the his actual conversion rate of 90.9%. . The process of pulling estimates back towards the average is sometimes referred to as &#39;shrinkage&#39;, which is illustrated more clearly in the interactive chart below. Teams with a small number of attempts are pulled back towards the prior estimate (the horizontal line) significantly, whereas teams with &gt; 150 attempts have a predicted conversion rate close to their actual conversion rate (i.e. close to the diagonal line). In other words, more evidence = less shrinkage, and vice versa. . teams = teams.assign(predicted_conversion=predicted_conversion(teams[&#39;penalties_scored&#39;], teams[&#39;penalties_taken&#39;])) # Set colour scheme to update automatically for each chart scheme = &#39;inferno&#39; col1 = matplotlib.colors.to_hex(sns.color_palette(scheme)[0]) col2 = matplotlib.colors.to_hex(sns.color_palette(scheme)[-1]) # Create an interactive scatter plot from teams showing predicted and actual conversion rate selection = alt.selection_single(on=&#39;mouseover&#39;); points = alt.Chart(teams).mark_circle(size=50).add_selection( selection ).encode( x=alt.X(&#39;conversion_rate&#39;, scale=alt.Scale(domain=(0.1, 1.1)), axis=alt.Axis(format=&#39;%&#39;, title=&#39;Actual conversion rate&#39;)), y=alt.X(&#39;predicted_conversion&#39;, scale=alt.Scale(domain=(0.685, 0.875)), axis=alt.Axis(format=&#39;%&#39;, title=&#39;Predicted conversion rate&#39;)), color=alt.condition(selection, &#39;penalties_taken:Q&#39;, alt.value(&#39;grey&#39;), legend=alt.Legend(title=&#39;Penalties taken&#39;), scale=alt.Scale(scheme=scheme)), opacity=alt.condition(selection, alt.value(0.8), alt.value(0.1)), tooltip=[&#39;team&#39;, &#39;penalties_scored&#39;, &#39;penalties_taken&#39;, alt.Tooltip(&#39;conversion_rate&#39;, format=&#39;.2%&#39;), alt.Tooltip(&#39;predicted_conversion&#39;, format=&#39;.2%&#39;)] ).interactive().properties( width=500, height=500, title=&#39;As the number of penalties taken increases, predicted rate approaches actual rate&#39; ) # Add horizontal line at y = alpha0 / (alpha0 + beta0) overlayh = pd.DataFrame({&#39;y&#39;: [prior]}) hline = alt.Chart(overlayh).mark_rule(color=col1, strokeWidth=2).encode(y=&#39;y:Q&#39;) overlayhtext = pd.DataFrame({&#39;x&#39;: [0.4], &#39;y&#39;: [prior], &#39;text&#39;: [&#39;Prior: y = alpha0 / (alpha0 + beta0)&#39;]}) htext = alt.Chart(overlayhtext).mark_text(color=col1, fontSize=15, baseline=&#39;bottom&#39;).encode(alt.X(&#39;x:Q&#39;), alt.Y(&#39;y:Q&#39;), alt.Text(&#39;text&#39;)) # Add diagonal line at y = x overlayd = pd.DataFrame({&#39;x&#39;: [-5, 0.7, 5], &#39;y&#39;: [-5, 0.7, 5], &#39;text&#39;: [&#39;&#39;, &#39;y = x&#39;, &#39;&#39;]}) dline = alt.Chart(overlayd).mark_line(color=col2, strokeWidth=2).encode(x=&#39;x:Q&#39;, y=&#39;y:Q&#39;) dtext = alt.Chart(overlayd).mark_text(color=col2, fontSize=15, angle=285, baseline=&#39;top&#39;).encode(alt.X(&#39;x:Q&#39;), alt.Y(&#39;y:Q&#39;), alt.Text(&#39;text&#39;)) alt.layer(points, hline, htext, dline, dtext ).configure_header( titleFontSize=20, titleFontWeight=&#39;normal&#39; ).configure_axis( labelFontSize=11, titleFontSize=14, titleFontWeight=&#39;normal&#39; ).configure_legend( labelFontSize=11, titleFontSize=12, titleFontWeight=&#39;normal&#39; ) . . Who are the best and worst penalty takers? . As we saw earlier, most players in the dataset have only taken a handful of penalties, and some of the players ranked worst in our new metric were players that happened to miss several times in their first few attempts. It might be more interesting to look at players who have taken at least 15 penalties (i.e. a team&#39;s main penalty taker for multiple seasons) instead. Let&#39;s start with the worst players in the dataset: . name penalties_scored penalties_taken conversion_rate predicted_conversion . 1330 Marek Ham≈°√≠k | 7 | 15 | 46.67% | 69.22% | . 1309 Marco Di Vaio | 13 | 22 | 59.09% | 71.10% | . 1152 Kevin Phillips | 11 | 18 | 61.11% | 72.56% | . 125 Andrea Pirlo | 14 | 22 | 63.64% | 72.72% | . 1771 Roberto Baggio | 12 | 19 | 63.16% | 73.03% | . 2107 Wayne Rooney | 23 | 34 | 67.65% | 73.09% | . 501 Diego | 13 | 20 | 65.00% | 73.48% | . 1163 Klaas-Jan Huntelaar | 11 | 17 | 64.71% | 73.84% | . 1226 Luca Toni | 17 | 25 | 68.00% | 73.98% | . 650 Fernando Torres | 20 | 29 | 68.97% | 74.04% | . Some surprising names there perhaps! Pirlo consistently pops up on &#39;best penalty takers&#39; lists, but even if we look at his overall record on Transfermarkt we get a predicted conversion rate of just 74.5%. Roberto Baggio&#39;s career record, on the other hand, is much better than it looks here (83.2%). . Note: Transfermarkt&#8217;s league coverage isn&#8217;t exhaustive but I haven&#8217;t yet found a more comprehensive resource for penalty stats, so I will be using their &#8217;career&#8217; totals throughout the post to supplement the FBRef data. . What about the best players in the dataset? . name penalties_scored penalties_taken conversion_rate predicted_conversion . 1599 Olivier Monterrubio | 27 | 27 | 100.00% | 86.77% | . 1398 Matt Le Tissier | 24 | 24 | 100.00% | 86.15% | . 1825 Ryad Boudebouz | 20 | 20 | 100.00% | 85.22% | . 74 Alessandro Del Piero | 42 | 46 | 91.30% | 85.03% | . 371 Cristhian Stuani | 17 | 17 | 100.00% | 84.43% | . 609 Fabinho | 17 | 17 | 100.00% | 84.43% | . 1544 Nen√™ | 22 | 23 | 95.65% | 84.33% | . 382 Cristiano Ronaldo | 91 | 105 | 86.67% | 84.23% | . 544 Eden Hazard | 26 | 28 | 92.86% | 84.01% | . 1419 Max Kruse | 15 | 15 | 100.00% | 83.86% | . It&#39;s not surprising to see Le Tissier up there, since he is widely considered to be one of the best penalty takers ever. Rickie Lambert only took a few penalties in the Premiership, but he is at 87.24% over his career in all competitions. If you are following along in notebook form you can investigate different players below; some notable names that weren&#39;t in the dataset include goalkeeper Rog√©rio Ceni (84.11%), Michel Platini (86.36%), Marco Van Basten (86.46%), Davor Suker (88.03%), Ferenc Pusk√°s (88.19%), Ronald Koeman (89.54%) and Alan Shearer (89.86%, more on him later!). The best I&#39;ve found so far is Hugo S√°nchez, who&#39;s 65/65 record puts him at 91.57%! . #@title Search for a player: { run: &quot;auto&quot;, vertical-output: true } text = &#39;Totti&#39; #@param {type:&quot;string&quot;} display(players[players[&#39;name&#39;].str.contains(text)]) # Alternative method (non-Colab Jupyter notebooks) def player_search(): text = widgets.Text() display(text) button = widgets.Button(description=&#39;Search&#39;) display(button) def on_button_clicked(b): return display(players[players[&#39;name&#39;].str.contains(text.value)]) button.on_click(on_button_clicked) . . name penalties_scored penalties_taken conversion_rate predicted_conversion . 684 Francesco Totti | 70 | 85 | 82.35% | 80.89% | . #@title Get predicted conversion rate: { run: &quot;auto&quot;, vertical-output: true } scored = 65 #@param {type:&quot;slider&quot;, min:0, max:150, step:1} missed = 0 #@param {type:&quot;slider&quot;, min:0, max:150, step:1} print(&#39;Scored:&#39;, scored, &#39;Missed:&#39;, missed) print(&#39;Predicted conversion rate: {:.2%}&#39;.format(predicted_conversion(scored, scored + missed))) # Alternative method (non-Colab Jupyter notebooks) def player_slider(): def slider(scored, missed): print(&#39;Scored:&#39;, scored, &#39;Missed:&#39;, missed) print(&#39;Predicted conversion rate: {:.2%}&#39;.format(predicted_conversion(scored, scored + missed))) interact(slider, scored=widgets.IntSlider(min=0, max=150, step=1, value=65), missed=widgets.IntSlider(min=0, max=150, step=1, value=0)) . . Scored: 65 Missed: 0 Predicted conversion rate: 91.57% . You might have noticed that this is a rare top ten list without Messi, and in the past he has even been called out for being &#39;phenomenally bad&#39; at penalties. Let&#39;s check whether that criticism was warranted. . Is Lionel Messi &#39;phenomenally bad&#39; at penalties? . Pretty average, actually. . # Initialise the plot fig, ax = plt.subplots(figsize=(9,6)) ax.set(title=&#39;Lionel Messi, Mr. Average&#39;, ylim=[0, 13], xlabel=&#39;Predicted penalty conversion rate&#39;) ax.xaxis.set_major_formatter(matplotlib.ticker.PercentFormatter(1)) # Generate a beta distribution representing the range of estimates for an average player sns.kdeplot(data=prior_dist, color=&#39;maroon&#39;, fill=True, bw_adjust=3) plt.axvline(prior, 0, 0.95, c=&#39;maroon&#39;, linestyle=&#39;--&#39;) # Generate a beta distribution representing the range of estimates for Messi # Note - using career numbers from Transfermarkt # https://www.transfermarkt.com/lionel-messi/elfmetertore/spieler/28003 goals = 97 misses = 26 messi_dist = ss.beta.rvs(alpha0+goals, beta0+misses, size=10000) sns.kdeplot(data=messi_dist, color=&#39;mediumblue&#39;, fill=True, bw_adjust=3) est1 = predicted_conversion(goals, goals+misses) plt.axvline(est1, 0, 0.95, c=&#39;mediumblue&#39;) # Add custom legend and axes custom_lines = [Line2D([0], [0], color=&#39;mediumblue&#39;, lw=2.5), Line2D([0], [0], color=&#39;maroon&#39;, lw=2.5, linestyle=&#39;--&#39;)] ax.legend(custom_lines, [&#39;Messi: %s&#39; % (str(round(est1*100, 1)))+&#39;%&#39;, &#39;Prior: %s&#39; % (str(round(prior*100, 1)))+&#39;%&#39;], loc=&#39;upper left&#39;) sns.despine(right=True, top=True); . . The beta distribution for our prior estimate is shown in red, with Messi&#39;s beta distribution in blue. . Tip: Definitely make your charts look worse by using Barcelona colours! . The distribution for Messi is taller and narrower than the prior distribution. This is because we have 123 penalty attempts for Messi, whereas our prior distribution starts off with a lot less, so we are more confident in Messi&#39;s prediction. We can also see that whilst Messi isn&#39;t &#39;phenomenally bad&#39; at penalties, in this case we may have found something he doesn&#39;t excel at. . Are Manchester City bad at penalties? . # Filter to the start of the 16/17 season teams_since_16 = df[df[&#39;season&#39;]&gt;2016].groupby(&#39;team&#39;)[[&#39;penalties_scored&#39;, &#39;penalties_taken&#39;]].sum().reset_index() conversion_rate(teams_since_16) teams_since_16 = teams_since_16.assign(predicted_conversion=predicted_conversion(teams_since_16[&#39;penalties_scored&#39;], teams_since_16[&#39;penalties_taken&#39;])) def percentile(all_scores, score): return round(ss.stats.percentileofscore(all_scores, score), 1) city_pct = percentile(teams_since_16[&#39;penalties_taken&#39;], teams_since_16.set_index(&#39;team&#39;).loc[&#39;Manchester City&#39;, &#39;penalties_taken&#39;]) print(&#39;Manchester City have taken more penalties than &#39;+str(city_pct)+&quot;% of teams nin Europe&#39;s big five leagues since 16/17. However...&quot;) . . Manchester City have taken more penalties than 84.5% of teams in Europe&#39;s big five leagues since 16/17. However... . palette = sns.color_palette() score = teams_since_16.set_index(&#39;team&#39;).loc[&#39;Manchester City&#39;, &#39;predicted_conversion&#39;] worse_or_equal = teams_since_16[teams_since_16[&#39;predicted_conversion&#39;]&lt;=score] worse_teams = len(worse_or_equal) - 1 # Create the main plot fig, ax = plt.subplots(figsize=(10,7)) ax.set(title=&quot;Since Pep Guardiola took charge in 16/17, only %d teams in Europe&#39;s big five leagues nhave a worse predicted penalty conversion rate than Manchester City&quot; % (worse_teams), ylim=[0, 20], xlabel=&#39;Predicted penalty conversion rate&#39;) ax.xaxis.set_major_formatter(matplotlib.ticker.PercentFormatter(1)) sns.kdeplot(data=teams_since_16[&#39;predicted_conversion&#39;], color=&#39;skyblue&#39;, fill=True) plt.axvline(teams_since_16[&#39;predicted_conversion&#39;].mean(), 0, 20, c=&#39;skyblue&#39;, linestyle=&#39;--&#39;) lineheight = 0.65*teams_since_16[teams_since_16[&#39;team&#39;]==&#39;Manchester City&#39;][&#39;penalties_taken&#39;].values[0]/teams_since_16[&#39;penalties_taken&#39;].max() textheight = 20.5*lineheight plt.axvline(score, 0, lineheight, c=palette[0]) plt.text(score, textheight, &#39;Manchester City&#39;, c=palette[0], ha=&#39;right&#39;) # Add rug - https://seaborn.pydata.org/generated/seaborn.rugplot.html#seaborn.rugplot sns.rugplot(data=teams_since_16[&#39;predicted_conversion&#39;], color=&#39;skyblue&#39;, height=0.035) # Add legend custom_lines = [Line2D([0], [0], color=palette[0], lw=2.5), Line2D([0], [0], color=&#39;skyblue&#39;, lw=2.5, linestyle=&#39;--&#39;), Line2D([0], [0], color=&#39;skyblue&#39;, lw=2.5)] ax.legend(custom_lines, [&#39;Manchester City: %s&#39; % (str(round(score*100, 1))+&#39;%&#39;), &#39;Average Team: %s&#39; % (str(round(teams_since_16[&#39;predicted_conversion&#39;].mean()*100, 1))+&#39;%&#39;), &#39;%d total teams&#39; % (len(teams_since_16))]) # Remove axes sns.despine(right=True, top=True); . . team penalties_scored penalties_taken conversion_rate predicted_conversion . 73 Manchester City | 16 | 25 | 64.00% | 72.44% | . 107 Stoke City | 0 | 3 | 0.00% | 72.29% | . 118 Valladolid | 10 | 17 | 58.82% | 72.08% | . 5 Atalanta | 15 | 24 | 62.50% | 72.00% | . 17 Brest | 2 | 6 | 33.33% | 71.92% | . 87 N√ºrnberg | 2 | 6 | 33.33% | 71.92% | . There&#39;s always going to be some variance involved in a stat like that, but there could be other factors at play as well: . # Data from https://www.transfermarkt.com/manchester-city/elfmeterschuetzen/verein/281 # KDB&#39;s estimate includes his miss against Liverpool man_city_career = {&#39;name&#39;: [&#39;Elano&#39;, &#39;Yaya Tour√©&#39;, &#39;Sergio Ag√ºero&#39;, &#39;Carlos Tevez&#39;, &#39;Robinho&#39;, &#39;Mario Balotelli&#39;, &#39;James Milner&#39;, &#39;Raheem Sterling&#39;, &#39;Kevin De Bruyne&#39;, &#39;Gabriel Jesus&#39;, &#39;ƒ∞lkay G√ºndoƒüan&#39;, &#39;Riyad Mahrez&#39;], &#39;penalties_scored&#39;: [23,15,47,24,12,38,30, 2,7,4,9,10], &#39;penalties_taken&#39;: [26,15,60,34,15,43,35, 4,9,10,10,16], &#39;align&#39;: [&#39;left&#39;, &#39;left&#39;, &#39;left&#39;, &#39;right&#39;, &#39;left&#39;, &#39;left&#39;, &#39;center&#39;, &#39;center&#39;, &#39;right&#39;, &#39;right&#39;, &#39;center&#39;, &#39;right&#39;], &#39;palette&#39;: [0,0,2,0,0,0,0, 2,2,2,1,2]} man_city = pd.DataFrame.from_dict(man_city_career) man_city = man_city.assign(predicted_conversion=predicted_conversion(man_city[&#39;penalties_scored&#39;], man_city[&#39;penalties_taken&#39;])).sort_values(by=&#39;predicted_conversion&#39;, ascending=False) # Create the main plot fig, ax = plt.subplots(figsize=(13,8)) ax.set(title=&#39;Hughes, Mancini and Pellegrini had far better options from the penalty spot than Pep Guardiola&#39;, ylim=[0, 27], xlabel=&#39;Predicted penalty conversion rate&#39;) ax.xaxis.set_major_formatter(matplotlib.ticker.PercentFormatter(1)) palette = sns.color_palette() sns.kdeplot(data=players[&#39;predicted_conversion&#39;], color=&#39;skyblue&#39;, fill=True, bw_adjust=3) # Add mean plt.axvline(players[&#39;predicted_conversion&#39;].mean(), 0, 27, c=&#39;skyblue&#39;, linestyle=&#39;--&#39;) for index, row in man_city.iterrows(): # Set line height to be proportional to number of penalties taken lineheight = row[&#39;penalties_taken&#39;]/players[&#39;penalties_taken&#39;].max() textheight = 27.5*lineheight plt.axvline(row[&#39;predicted_conversion&#39;], 0, lineheight, c=palette[row[&#39;palette&#39;]]) plt.text(row[&#39;predicted_conversion&#39;], textheight, row[&#39;name&#39;], c=palette[row[&#39;palette&#39;]], ha=row[&#39;align&#39;]) # Add rug sns.rugplot(data=players[&#39;predicted_conversion&#39;], color=&#39;skyblue&#39;, height=0.02) # Add legend custom_lines = [Line2D([0], [0], color=palette[0], lw=2.5), Line2D([0], [0], color=palette[2], lw=2.5), Line2D([0], [0], color=palette[1], lw=2.5), Line2D([0], [0], color=&#39;skyblue&#39;, lw=2.5, linestyle=&#39;--&#39;), Line2D([0], [0], color=&#39;skyblue&#39;, lw=2.5),] ax.legend(custom_lines, [&#39;Mansour era nbefore 16/17&#39;, &#39;Guardiola era&#39;, &#39;Current best&#39;, &#39;Average player&#39;, &#39;%d total players&#39; % (len(players))]) # Remove axes sns.despine(right=True, top=True); . . We can clearly see a big difference here pre/post Pep (with the exception of Carlos Tevez, who mainly took penalties in 09/10 after Elano left). In fact, the wealth of options meant that James Milner was rarely called upon to take penalties for City. Balotelli famously never needs to look at the ball when he takes a penalty - Joe Hart once said that his penalties were almost impossible to stop, which was far greater praise at the time than it would be now (sorry Joe!), and did a lap of honour when he finally saved one in training. To answer our earlier question, not only is Yaya Tour√© significantly better than Gabriel Jesus, they are on opposite ends of the scale! Jesus is great at many aspects of the game, but from the penalty spot he&#39;s one of the worst players I&#39;ve seen with a 70.15% predicted conversion rate. . # Plot the range of estimates for Yaya and Jesus fig, ax = plt.subplots(figsize=(9,6)) ax.set(title=&#39;Yaya Tour√© and Gabriel Jesus are probably not equally skilled at taking penalties&#39;, ylim=[0, 9], xlabel=&#39;Predicted penalty conversion rate&#39;) ax.xaxis.set_major_formatter(matplotlib.ticker.PercentFormatter(1)) # Yaya goals = 15 misses = 0 yaya_dist = ss.beta.rvs(alpha0+goals, beta0+misses, size=10000) sns.kdeplot(data=yaya_dist, color=palette[0], fill=True, bw_adjust=1.5) est1 = predicted_conversion(goals, goals+misses) plt.axvline(est1, 0, 0.95, c=palette[0], linestyle=&#39;--&#39;) # Jesus goals = 4 misses = 6 jesus_dist = ss.beta.rvs(alpha0+goals, beta0+misses, size=10000) sns.kdeplot(data=jesus_dist, color=&#39;skyblue&#39;, fill=True, bw_adjust=1.5) est2 = predicted_conversion(goals, goals+misses) plt.axvline(est2, 0, 0.95, c=&#39;skyblue&#39;, linestyle=&#39;--&#39;) # Add custom legend and axes custom_lines = [Line2D([0], [0], color=&#39;skyblue&#39;, lw=2.5), Line2D([0], [0], color=palette[0], lw=2.5)] ax.legend(custom_lines, [&#39;Jesus: %s&#39; % (str(round(est2*100, 1)))+&#39;%&#39;, &#39;Tour√©: %s&#39; % (str(round(est1*100, 1)))+&#39;%&#39;], loc=&#39;upper left&#39;) sns.despine(right=True, top=True); . . Aside from his well publicised disagreements with Tour√© it&#39;s hard to blame Pep too much, since it appears his current squad are good at everything but penalties. ƒ∞lkay G√ºndoƒüan&#39;s miss came at a time when City had already missed three of their last five so we can certainly speculate that there would have been a lot of pressure to change things; in fact as I alluded to earlier things got so bad that Pep was seriously considering putting Ederson in charge of spot kicks. De Bruyne&#39;s miss against Liverpool bumped his estimate down to about league average, but he was still predicted to be a bit worse than G√ºndoƒüan before that: . # Plot the range of estimates for KDB before and after his penalty against Liverpool fig, ax = plt.subplots(figsize=(9,6)) ax.set(title=&quot;De Bruyne&#39;s predicted conversion rate decreased after his miss against Liverpool&quot;, ylim=[0, 9], xlabel=&#39;Predicted penalty conversion rate&#39;) ax.xaxis.set_major_formatter(matplotlib.ticker.PercentFormatter(1)) # Before Liverpool penalty goals = 7 misses = 1 kdb_dist = ss.beta.rvs(alpha0+goals, beta0+misses, size=10000) sns.kdeplot(data=kdb_dist, color=&#39;skyblue&#39;, fill=True, bw_adjust=1.5) est1 = predicted_conversion(goals, goals+misses) plt.axvline(est1, 0, 0.95, c=&#39;skyblue&#39;, linestyle=&#39;--&#39;) # After Liverpool penalty misses = 2 kdb_dist = ss.beta.rvs(alpha0+goals, beta0+misses, size=10000) sns.kdeplot(data=kdb_dist, color=palette[0], bw_adjust=1.5) est2 = predicted_conversion(goals, goals+misses) plt.axvline(est2, 0, 0.95, c=palette[0], linestyle=&#39;--&#39;) # Add custom legend and axes custom_lines = [Line2D([0], [0], color=palette[0], lw=2.5), Line2D([0], [0], color=&#39;skyblue&#39;, lw=2.5)] ax.legend(custom_lines, [&#39;New estimate: %s&#39; % (str(round(est2*100, 1)))+&#39;%&#39;, &#39;Old estimate: %s&#39; % (str(round(est1*100, 1)))+&#39;%&#39;], loc=&#39;upper left&#39;) sns.despine(right=True, top=True); . . ƒ∞lkay G√ºndoƒüan is at the 92.2th percentile of 2204 players in the dataset with a predicted penalty conversion rate of 80.22%! . This analysis suggests G√ºndoƒüan deserves another go, and I&#39;d like to see him given the nod the next time he&#39;s on the pitch. We aren&#39;t talking about a massive difference between the two players, but why not take edges anywhere you can, even if they are small ones? We have to assume Ederson is worse than G√ºndoƒüan as well since we have no additional data, but if Ederson really is City&#39;s best penalty taker then why not use him - it can&#39;t really get much worse at this point! . Why isn&#39;t Aleksandar Mitrovi&#263; taking penalties for Fulham? . Antonin Panenka (83.5% predicted conversion rate) might not have been too pleased with the result of Ademola Lookman&#39;s botched attempt against West Ham last weekend. Lookman was heavily criticised, and at the time I was wondering why Aleksandar Mitroviƒá wasn&#39;t the one taking the penalty. Now I know why: . fulham_career = {&#39;name&#39;: [&#39;Aleksandar Mitroviƒá&#39;, &#39;Tom Cairney&#39;, &#39;Ivan Cavaleiro&#39;, &#39;Ademola Lookman n(before miss)&#39;], &#39;penalties_scored&#39;: [15,2,6,0], &#39;penalties_taken&#39;: [22,3,7,0]} fulham = pd.DataFrame.from_dict(fulham_career) fulham = fulham.assign(predicted_conversion=predicted_conversion(fulham[&#39;penalties_scored&#39;], fulham[&#39;penalties_taken&#39;])).sort_values(by=&#39;predicted_conversion&#39;, ascending=False) fulham[&#39;penalties_missed&#39;] = fulham[&#39;penalties_taken&#39;] - fulham[&#39;penalties_scored&#39;] dist_df = pd.DataFrame() for index, row in fulham.iterrows(): dist = ss.beta.rvs(alpha0+row[&#39;penalties_scored&#39;], beta0+row[&#39;penalties_missed&#39;], size=10000) temp = pd.DataFrame({&#39;predicted_conversion&#39;: dist}) temp[&#39;name&#39;] = row[&#39;name&#39;] dist_df = dist_df.append(temp) fig, ax = plt.subplots(figsize=(10,6)) ax.set(title=&quot;It&#39;s not surprising that Aleksandar Mitroviƒá isn&#39;t taking penalties for Fulham&quot;) ax.xaxis.set_major_formatter(matplotlib.ticker.PercentFormatter(1)) sns.violinplot(data=dist_df, x=&#39;predicted_conversion&#39;, y=&#39;name&#39;, palette=&#39;light:dimgrey&#39;, inner=&#39;quart&#39;, orient=&#39;h&#39;, ax=ax) plt.xlabel(&#39;Predicted penalty conversion rate&#39;) plt.ylabel(&#39;&#39;) sns.despine(right=True, top=True); . . Aleksandar Mitroviƒá is at the 3.8th percentile of 2204 players in the dataset with a predicted penalty conversion rate of 74.34%! . It&#39;s a good job Mitroviƒá isn&#39;t first choice! Cavaleiro appears to be the best candidate by our estimate, but maybe Lookman showed something in training that set him apart from the rest - the Fulham coaches will have seen him take a lot more penalties than we have. Going for a &#39;Panenka&#39; on your first attempt certainly suggests that you at least rate your own ability from the spot pretty highly, although if we use that logic maybe we should be recommending John Stones as City&#39;s go-to option... . Simulating the Euro 96 semi-final shootout . At this point it seems inevitable to most England fans that every major tournament will end in a penalty shootout loss to Germany in the semis. . . Let&#39;s have a look at one example, the Euro 96 shootout, and see whether that&#39;s really the case. . # https://www.transfermarkt.com/spielbericht/index/spielbericht/935928 eng_career = {&#39;name&#39;: [&#39;Alan Shearer&#39;, &#39;Teddy Sheringham&#39;, &#39;Steve McManaman&#39;, &#39;Paul Ince&#39;, &#39;David Platt&#39;, &#39;Paul Gascoigne&#39;, &#39;Darren Anderton&#39;, &#39;Gareth Southgate&#39;, &#39;Tony Adams&#39;, &#39;Stuart Pearce&#39;, &#39;David Seaman&#39;, &#39;Robbie Fowler&#39;], &#39;penalties_scored&#39;: [65,30,0,0,13, 1,6,0,0,10, 0,32], &#39;penalties_taken&#39;: [67,33,0,0,15, 1,6,0,0,10, 0,34], &#39;notes&#39;: [None, None, None, None, None, None, None, None, None, None, None, &#39;bench, not used&#39;]} ger_career = {&#39;name&#39;: [&#39;Stefan Kuntz&#39;, &#39;Mehmet Scholl&#39;, &#39;Andreas M√∂ller&#39;, &#39;Christian Ziege&#39;, &#39;Dieter Eilts&#39;, &#39;Stefan Reuter&#39;, &#39;Matthias Sammer&#39;, &#39;Markus Babbel&#39;, &#39;Andreas K√∂pke&#39;, &#39;Thomas Strunz&#39;, &#39;Thomas H√§√üler&#39;, &#39;Marco Bode&#39;, &#39;Oliver Bierhoff&#39;], &#39;penalties_scored&#39;: [34,14,9,2,8, 10,0,0,2,4, 26,0,15], &#39;penalties_taken&#39;: [39,17,13,3,8, 15,0,0,2,5, 28,1,20], &#39;notes&#39;: [None, &quot;subbed off 77&#39;&quot;, None, None, None, None, None, None, None, &quot;subbed on 118&#39;&quot;, &quot;subbed on 77&#39;&quot;, &quot;subbed on 110&#39;&quot;, &quot;bench, not used&quot;]} england = pd.DataFrame.from_dict(eng_career) england = england.assign(predicted_conversion=predicted_conversion(england[&#39;penalties_scored&#39;], england[&#39;penalties_taken&#39;])).sort_values(by=&#39;predicted_conversion&#39;, ascending=False) germany = pd.DataFrame.from_dict(ger_career) germany = germany.assign(predicted_conversion=predicted_conversion(germany[&#39;penalties_scored&#39;], germany[&#39;penalties_taken&#39;])).sort_values(by=&#39;predicted_conversion&#39;, ascending=False) england . . name penalties_scored penalties_taken notes predicted_conversion . 0 Alan Shearer | 65 | 67 | None | 89.86% | . 11 Robbie Fowler | 32 | 34 | bench, not used | 85.31% | . 1 Teddy Sheringham | 30 | 33 | None | 83.73% | . 9 Stuart Pearce | 10 | 10 | None | 82.24% | . 6 Darren Anderton | 6 | 6 | None | 80.68% | . 4 David Platt | 13 | 15 | None | 80.20% | . 5 Paul Gascoigne | 1 | 1 | None | 78.31% | . 2 Steve McManaman | 0 | 0 | None | 77.76% | . 3 Paul Ince | 0 | 0 | None | 77.76% | . 7 Gareth Southgate | 0 | 0 | None | 77.76% | . 8 Tony Adams | 0 | 0 | None | 77.76% | . 10 David Seaman | 0 | 0 | None | 77.76% | . It looks like England actually had some good penalty takers available, particularly Shearer who has one of the highest predicted conversion rates we have found so far. Robbie Fowler was still young at the time, but it&#39;s notable that England didn&#39;t choose to bring him on just before the shootout despite having three substitutions remaining, since he was prolific from the spot later in his career. . name penalties_scored penalties_taken notes predicted_conversion . 10 Thomas H√§√üler | 26 | 28 | subbed on 77&#39; | 84.01% | . 0 Stefan Kuntz | 34 | 39 | None | 82.43% | . 4 Dieter Eilts | 8 | 8 | None | 81.49% | . 1 Mehmet Scholl | 14 | 17 | subbed off 77&#39; | 79.14% | . 8 Andreas K√∂pke | 2 | 2 | None | 78.83% | . 9 Thomas Strunz | 4 | 5 | subbed on 118&#39; | 78.01% | . 6 Matthias Sammer | 0 | 0 | None | 77.76% | . 7 Markus Babbel | 0 | 0 | None | 77.76% | . 3 Christian Ziege | 2 | 3 | None | 76.98% | . 12 Oliver Bierhoff | 15 | 20 | bench, not used | 76.83% | . 11 Marco Bode | 0 | 1 | subbed on 110&#39; | 75.85% | . 2 Andreas M√∂ller | 9 | 13 | None | 75.65% | . 5 Stefan Reuter | 10 | 15 | None | 74.71% | . Germany did make some substitutions however, bringing their best penalty taker Thomas H√§√üler on in normal time in addition to Marco Bode and Thomas Strunz in extra time. Whilst Bode (a winger) looks worse than average at penalties he was subbed on for a centre-back in an attempt to win the game in extra-time, and he wasn&#39;t chosen as one of the top six options in the shootout. It&#39;s interesting that Thomas Strunz was brought on to take the second penalty in favour of Oliver Bierhoff (who scored twice in the final), since our estimate is that Bierhoff is below average from the spot. Maybe the coaches were onto something... Captain Andreas M√∂ller scored the winning penalty in sudden-death, but it looks like he was probably a below average penalty taker also. . Note: Just a reminder that I&#8217;m still ignoring goalkeeper skill, but Andreas K√∂pke saved 22/84 penalties in his career, so maybe it&#8217;s harder to score against him than a typical goalie! . # Remove unwanted players fowler = england.copy()[england[&#39;name&#39;]==&#39;Robbie Fowler&#39;] england = england.copy()[england[&#39;name&#39;]!=&#39;Robbie Fowler&#39;] germany = germany.copy()[~germany[&#39;name&#39;].isin([&#39;Mehmet Scholl&#39;, &#39;Oliver Bierhoff&#39;])] # Order the players to get Platt taking the second penalty etc # We only know the first six players for each team, so assume the order for the rest england[&#39;order&#39;] = [1,5,3,7,2,4,8,9,6,10,11] england = england.copy().sort_values(&#39;order&#39;) germany[&#39;order&#39;] = [1,5,7,8,2,9,10,4,11,6,3] germany = germany.copy().sort_values(&#39;order&#39;) . . We can see which team is expected to win the shootout by simulating it using the predicted conversion rates for each player to determine whether they scored or missed their penalty. Here is one simulation: . def shootout(team_a, team_b, printer=False): &quot;&quot;&quot;Function to simulate a penalty shootout. Takes two dataframes as input, one for each team. The dataframe should be sorted in the order used for the shootout, i.e. the first player to take a penalty should be at row 1, the second at row 2 etc. &quot;&quot;&quot; a_score = 0 b_score = 0 a_wins = 0 b_wins = 0 a_index = 0 b_index = 0 # df index should be from 0 to len(df) team_a = team_a.reset_index().drop(&#39;index&#39;, axis=1) team_b = team_b.reset_index().drop(&#39;index&#39;, axis=1) while a_wins == b_wins: # Reset index to 0 if every player has taken a penalty in this round if a_index &gt; len(team_a)-1: a_index = 0 if b_index &gt; len(team_b)-1: b_index = 0 # Get Team A result a_player = team_a.iloc[a_index, 0] a_prob = team_a.iloc[a_index, 4] a_result = np.random.choice([0,1], 1, p=[1-a_prob, a_prob]) a_score += a_result if printer != False: print(a_player+&#39;...scores! (%d-%d)&#39; % (a_score, b_score) if a_result ==1 else a_player+&#39;...misses! (%d-%d)&#39; % (a_score, b_score)) # Get Team B result b_player = team_b.iloc[a_index, 0] b_prob = team_b.iloc[a_index, 4] b_result = np.random.choice([0,1], 1, p=[1-a_prob, a_prob]) b_score += b_result if printer != False: print(b_player+&#39;...scores! (%d-%d)&#39; % (a_score, b_score) if b_result ==1 else b_player+&#39;...misses! (%d-%d)&#39; % (a_score, b_score)) a_index += 1 b_index += 1 # Stop the shootout when scores are no longer equal and at least five penalties each have been taken if (a_index &gt;= 5): if (a_score &gt; b_score): a_wins += 1 if printer != False: print(&#39; nTeam A wins! (%d-%d)&#39; % (a_score, b_score)) elif (a_score &lt; b_score): b_wins += 1 if printer != False: print(&#39; nTeam B wins! (%d-%d)&#39; % (b_score, a_score)) return a_wins, b_wins # Run one penalty shootout _, _ = shootout(england, germany, printer=True) . . Alan Shearer...scores! (1-0) Thomas H√§√üler...misses! (1-0) David Platt...scores! (2-0) Thomas Strunz...scores! (2-1) Stuart Pearce...scores! (3-1) Stefan Reuter...scores! (3-2) Paul Gascoigne...scores! (4-2) Christian Ziege...scores! (4-3) Teddy Sheringham...misses! (4-3) Stefan Kuntz...scores! (4-4) Gareth Southgate...misses! (4-4) Andreas M√∂ller...misses! (4-4) Darren Anderton...scores! (5-4) Dieter Eilts...misses! (5-4) Team A wins! (5-4) . Let&#39;s run this thousands of times and calculate how often England would be expected to advance to the final: . num_sims = 5000 def simulate_shootouts(team_a, team_b, num_sims): a_wins = 0 b_wins = 0 for i in range(num_sims): a, b = shootout(team_a, team_b) a_wins += a b_wins += b return a_wins, b_wins eng_wins, ger_wins = simulate_shootouts(england, germany, num_sims) eng_win_pct = str(round((eng_wins/num_sims)*100, 1)) print(&#39;England win probability = %s&#39; % (eng_win_pct+&#39;%&#39;)) . . England win probability = 51.4% . Pretty close, but a loss wasn&#39;t inevitable at least! Unless you believe in curses, that is... . Conclusion . Thanks for reading! I hope you enjoyed this and learned something useful. We could have made a much more complicated model of penalty taking skill, but as discussed earlier extra complexity wouldn&#39;t necessarily be better here. By using empirical Bayes estimation we were able to get some interesting insights out of a limited dataset in just a few steps. If you want to explore this topic further you could use the same process to estimate penalty save percentage, or you could try to improve on this model. A couple of ways to do that would be to use more data or estimate different priors for different groups of players, e.g. should the prior distribution for a team&#39;s main penalty taker be the same as the prior for someone who was only trusted to take a handful of penalties in their career? Let me know what you find out! . Thanks again to David Robinson, whose work make this possible, and to FBRef and Transfermarkt for the data. .",
            "url": "https://www.thomaswhelan.com/bayes/football/visualisation/2020/11/14/evaluating-penalty-takers-using-empirical-bayes.html",
            "relUrl": "/bayes/football/visualisation/2020/11/14/evaluating-penalty-takers-using-empirical-bayes.html",
            "date": " ‚Ä¢ Nov 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "üë§ About Me",
          "content": "Tom Whelan . tom@thomaswhelan.com ¬∑ @tom_whelan ¬∑ twhelan22 I created this page to write about various data science and machine learning projects I have worked on. Previously I wrote a series teaching machine learning with Python through a fantasy football lens, which can be found at [fantasyfutopia.com](http://www.fantasyfutopia.com/python-for-fantasy-football-introduction/). .",
          "url": "https://www.thomaswhelan.com/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ ‚Äúsitemap.xml‚Äù | absolute_url }} | .",
          "url": "https://www.thomaswhelan.com/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}